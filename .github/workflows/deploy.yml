name: CD Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  PROJECT_ID: short-term-trade
  REGION: us-central1
  ZONE: us-central1-a
  AR_REPO: tqqq
  IMAGE_NAME: bot
  INSTANCE_NAME: tqqq-trading-bot

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Build with Cloud Build
        run: |
          # Submit build asynchronously to avoid log streaming permission issues
          BUILD_ID=$(gcloud builds submit \
            --config=cloudbuild.yaml \
            --substitutions=_IMAGE_URL=${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            --project=${{ env.PROJECT_ID }} \
            --gcs-source-staging-dir=gs://${{ env.PROJECT_ID }}_cloudbuild/source \
            --async \
            --format='value(id)')

          echo "Build ID: $BUILD_ID"

          # Wait for build to complete
          while true; do
            STATUS=$(gcloud builds describe $BUILD_ID --project=${{ env.PROJECT_ID }} --format='value(status)')
            echo "Build status: $STATUS"

            if [ "$STATUS" = "SUCCESS" ]; then
              echo "Build completed successfully!"
              break
            elif [ "$STATUS" = "FAILURE" ] || [ "$STATUS" = "TIMEOUT" ] || [ "$STATUS" = "CANCELLED" ]; then
              echo "Build failed with status: $STATUS"
              exit 1
            fi

            sleep 10
          done

      - name: Tag and push as latest
        run: |
          # Configure docker to authenticate with Artifact Registry
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

          # Pull the SHA-tagged image, tag as latest, and push
          docker pull ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker tag ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:latest

      - name: Deploy to GCE
        run: |
          # Check if instance exists
          if ! gcloud compute instances describe ${{ env.INSTANCE_NAME }} \
              --zone=${{ env.ZONE }} \
              --project=${{ env.PROJECT_ID }} &>/dev/null; then
            echo "Instance does not exist. Creating new instance..."

            # Create a basic startup script
            cat > /tmp/startup-script.sh << 'STARTUP_EOF'
          #!/bin/bash
          set -e

          # Install Docker
          if ! command -v docker &> /dev/null; then
              apt-get update
              apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
              curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
              echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list
              apt-get update
              apt-get install -y docker-ce docker-ce-cli containerd.io
              systemctl enable docker
              systemctl start docker
          fi

          # Configure Docker to use Artifact Registry
          gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet

          # Create directories
          mkdir -p /opt/tqqq/logs /opt/tqqq/reports

          # Get env file from Secret Manager
          gcloud secrets versions access latest --secret="tqqq-env-file" > /opt/tqqq/.env 2>/dev/null || touch /opt/tqqq/.env

          # Pull and run the trading bot
          docker pull ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:latest

          # Create systemd service
          cat > /etc/systemd/system/tqqq-trading-bot.service << 'SERVICE_EOF'
          [Unit]
          Description=TQQQ Trading Bot (Docker)
          After=docker.service
          Requires=docker.service

          [Service]
          Type=simple
          Restart=always
          RestartSec=30
          ExecStartPre=-/usr/bin/docker stop tqqq-bot
          ExecStartPre=-/usr/bin/docker rm tqqq-bot
          ExecStartPre=/usr/bin/docker pull ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:latest
          ExecStart=/usr/bin/docker run --rm --name tqqq-bot \
              --env-file /opt/tqqq/.env \
              -v /opt/tqqq/logs:/app/logs \
              ${{ env.REGION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.AR_REPO }}/${{ env.IMAGE_NAME }}:latest
          ExecStop=/usr/bin/docker stop tqqq-bot

          [Install]
          WantedBy=multi-user.target
          SERVICE_EOF

          # Enable and start service
          systemctl daemon-reload
          systemctl enable tqqq-trading-bot
          systemctl start tqqq-trading-bot
          STARTUP_EOF

            # Create instance with basic configuration
            gcloud compute instances create ${{ env.INSTANCE_NAME }} \
              --zone=${{ env.ZONE }} \
              --machine-type=e2-small \
              --scopes=cloud-platform \
              --image-family=debian-12 \
              --image-project=debian-cloud \
              --boot-disk-size=20GB \
              --boot-disk-type=pd-standard \
              --metadata-from-file=startup-script=/tmp/startup-script.sh \
              --tags=tqqq-runner \
              --project=${{ env.PROJECT_ID }}

            echo "Instance created. Waiting for startup to complete..."
            sleep 120
          else
            echo "Instance exists. Updating..."

            # Use startup-script metadata to trigger update on next boot/reset
            gcloud compute instances add-metadata ${{ env.INSTANCE_NAME }} \
              --zone=${{ env.ZONE }} \
              --metadata=deploy-version=${{ github.sha }}

            # Reset instance to apply changes (triggers systemd to pull new image)
            gcloud compute instances reset ${{ env.INSTANCE_NAME }} \
              --zone=${{ env.ZONE }}

            echo "Instance reset triggered. Waiting for startup..."
            sleep 60
          fi

      - name: Verify deployment
        run: |
          # Check instance status
          STATUS=$(gcloud compute instances describe ${{ env.INSTANCE_NAME }} \
            --zone=${{ env.ZONE }} \
            --format="value(status)")
          echo "Instance status: $STATUS"

          if [ "$STATUS" != "RUNNING" ]; then
            echo "Instance is not running!"
            exit 1
          fi
          echo "Deployment complete. Instance is running."

      - name: Notify Discord - Success
        if: success()
        run: |
          curl -H "Content-Type: application/json" \
            -d "{\"content\": \"✅ **배포 완료**\n\`${{ github.sha }}\`\n${{ github.event.head_commit.message }}\"}" \
            ${{ secrets.DISCORD_WEBHOOK_URL }}

      - name: Notify Discord - Failure
        if: failure()
        run: |
          curl -H "Content-Type: application/json" \
            -d "{\"content\": \"❌ **배포 실패**\n\`${{ github.sha }}\`\nhttps://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}" \
            ${{ secrets.DISCORD_WEBHOOK_URL }}
